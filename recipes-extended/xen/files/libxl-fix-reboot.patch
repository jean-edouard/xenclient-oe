From 80a360eaf7ffaa8ca85bffea039b15cce8fb97f2 Mon Sep 17 00:00:00 2001
From: Chris Rogers <rogersc@ainfosec.com>
Date: Wed, 26 Oct 2016 12:36:29 -0400
Subject: [PATCH 4/6] libxl-fix-reboot.patch

* Modified how xl handles domain reboots. Xen doesn't implement the hvm
  reset signal, so when a reboot comes from the toolstack, we send a shutdown
  and note that we're rebooting.

Signed-off-by: Chris Rogers <rogersc@ainfosec.com>
---
 tools/libxl/libxl_utils.c | 34 ++++++++++++++++++++++++++++++++++
 tools/libxl/libxl_utils.h |  2 ++
 tools/libxl/xl_cmdimpl.c  | 15 ++++++++++++++-
 3 files changed, 50 insertions(+), 1 deletion(-)

diff --git a/tools/libxl/libxl_utils.c b/tools/libxl/libxl_utils.c
index 64e2aee..0a83abf 100644
--- a/tools/libxl/libxl_utils.c
+++ b/tools/libxl/libxl_utils.c
@@ -1253,6 +1253,40 @@ int libxl_domid_valid_guest(uint32_t domid)
     return domid > 0 && domid < DOMID_FIRST_RESERVED;
 }
 
+int libxl_read_reboot(libxl_ctx *ctx, uint32_t domid, char **state)
+{
+    char path[49];
+    char uuid[37];
+    libxl_dominfo domain;
+
+    libxl_domain_info(ctx, &domain, domid);
+
+    uuid_unparse(domain.uuid.uuid, uuid);
+    sprintf(path, "/state/%s/reboot", uuid);    
+
+    *state = xs_read(ctx->xsh, XBT_NULL, path, NULL);
+
+    return 0;
+}
+
+int libxl_set_reboot(libxl_ctx *ctx, uint32_t domid, bool reboot)
+{
+    char path[49];
+    char uuid[37];
+    libxl_dominfo domain;
+
+    libxl_domain_info(ctx, &domain, domid);
+    uuid_unparse(domain.uuid.uuid, uuid);
+
+    sprintf(path, "/state/%s/reboot", uuid);
+    if(reboot)
+        xs_write(ctx->xsh, XBT_NULL, path, "1", strlen("1"));
+    else
+        xs_rm(ctx->xsh, XBT_NULL, path); 
+
+    return 0;
+}
+
 int libxl_update_state_direct(libxl_ctx *ctx, libxl_uuid xl_uuid, const char * state)
 {
     char path[48];
diff --git a/tools/libxl/libxl_utils.h b/tools/libxl/libxl_utils.h
index a737601..cd9f01d 100644
--- a/tools/libxl/libxl_utils.h
+++ b/tools/libxl/libxl_utils.h
@@ -41,6 +41,8 @@ int libxl_is_stubdom(libxl_ctx *ctx, uint32_t domid, uint32_t *target_domid);
 int libxl_create_logfile(libxl_ctx *ctx, const char *name, char **full_name);
 int libxl_string_to_backend(libxl_ctx *ctx, char *s, libxl_disk_backend *backend);
 int libxl_update_state(libxl_ctx *ctx, uint32_t domid_in, const char *state);
+int libxl_read_reboot(libxl_ctx *ctx, uint32_t domid_in, char **reboot);
+int libxl_set_reboot(libxl_ctx *ctx, uint32_t domid_in, bool reboot);
 int libxl_update_state_direct(libxl_ctx *ctx, libxl_uuid xl_uuid, const char *state);
 
 int libxl_read_file_contents(libxl_ctx *ctx, const char *filename,
diff --git a/tools/libxl/xl_cmdimpl.c b/tools/libxl/xl_cmdimpl.c
index 10c14b3..8e74763 100644
--- a/tools/libxl/xl_cmdimpl.c
+++ b/tools/libxl/xl_cmdimpl.c
@@ -2431,11 +2431,21 @@ static int handle_domain_death(uint32_t *r_domid,
 
 {
     int restart = 0;
+    char * reboot = NULL;
     libxl_action_on_shutdown action;
 
     switch (event->u.domain_shutdown.shutdown_reason) {
     case LIBXL_SHUTDOWN_REASON_POWEROFF:
         action = d_config->on_poweroff;
+        libxl_read_reboot(ctx, *r_domid, &reboot);
+        if(reboot)
+        {
+            if(strcmp(reboot, "1") == 0)
+            {
+                LOG("Setting domain action to reboot");
+                action = d_config->on_reboot;       
+            }
+        }
         break;
     case LIBXL_SHUTDOWN_REASON_REBOOT:
         action = d_config->on_reboot;
@@ -2489,6 +2499,7 @@ static int handle_domain_death(uint32_t *r_domid,
     case LIBXL_ACTION_ON_SHUTDOWN_RESTART:
         reload_domain_config(*r_domid, d_config);
         restart = 1;
+        libxl_set_reboot(ctx, *r_domid, 0);
         /* fall-through */
     case LIBXL_ACTION_ON_SHUTDOWN_DESTROY:
         LOG("Domain %d needs to be cleaned up: destroying the domain",
@@ -2891,6 +2902,7 @@ start:
         ret = libxl_domain_create_new(ctx, &d_config, &domid,
                                       0, autoconnect_console_how);
     }
+
     if ( ret )
         goto error_out;
 
@@ -3782,12 +3794,13 @@ static void reboot_domain(uint32_t domid, libxl_evgen_domain_death **deathw,
 
     fprintf(stderr, "Rebooting domain %d\n", domid);
     libxl_update_state(ctx, domid, "rebooting");
+    libxl_set_reboot(ctx, domid, 1);
     rc=libxl_domain_reboot(ctx, domid);
     if (rc == ERROR_NOPARAVIRT) {
         if (fallback_trigger) {
             fprintf(stderr, "PV control interface not available:"
                     " sending ACPI reset button event.\n");
-            rc = libxl_send_trigger(ctx, domid, LIBXL_TRIGGER_RESET, 0);
+            rc = libxl_send_trigger(ctx, domid, LIBXL_TRIGGER_POWER, 0);
         } else {
             fprintf(stderr, "PV control interface not available:"
                     " external graceful reboot not possible.\n");
-- 
2.1.4

