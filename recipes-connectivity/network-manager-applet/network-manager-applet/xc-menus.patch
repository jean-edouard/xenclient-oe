Index: network-manager-applet-1.4.4/src/applet.c
===================================================================
--- network-manager-applet-1.4.4.orig/src/applet.c
+++ network-manager-applet-1.4.4/src/applet.c
@@ -64,6 +64,17 @@ extern gboolean with_appindicator;
 
 G_DEFINE_TYPE (NMApplet, nma, G_TYPE_APPLICATION)
 
+enum {
+	POPUP_NETWORK_MENU,
+	CLOSE_NETWORK_MENU,
+	LAST_SIGNAL
+};
+static guint signals[LAST_SIGNAL] = { 0 };
+
+/* Forward declarations */
+static GtkWidget *nma_context_menu_create (NMApplet *applet);
+static void nma_context_menu_update (NMApplet *applet);
+
 /********************************************************************/
 
 static inline NMADeviceClass *
@@ -1306,12 +1317,17 @@ nma_menu_device_get_menu_item (NMDevice
 		struct AppletDeviceMenuInfo *info = g_new0 (struct AppletDeviceMenuInfo, 1);
 		info->device = g_object_ref (device);
 		info->applet = applet;
-		item = gtk_menu_item_new_with_label (_("Disconnect"));
-		g_signal_connect_data (item, "activate",
-		                       G_CALLBACK (applet_device_disconnect_db),
-		                       info,
-		                       (GClosureNotify) applet_device_info_destroy, 0);
-		gtk_widget_set_sensitive (item, TRUE);
+
+		NMDeviceType devtype = nm_device_get_device_type (device);
+		if (devtype != NM_DEVICE_TYPE_ETHERNET)
+		{
+			item = gtk_menu_item_new_with_label (_("Disconnect"));
+			g_signal_connect_data (item, "activate",
+					       G_CALLBACK (applet_device_disconnect_db),
+					       info,
+					       (GClosureNotify) applet_device_info_destroy, 0);
+			gtk_widget_set_sensitive (item, TRUE);
+		}
 		break;
 	}
 	default:
@@ -1443,6 +1459,9 @@ nma_menu_add_vpn_submenu (GtkWidget *men
 	GPtrArray *list;
 	int i;
 
+	/* Don't show VPN menu */
+	return;
+
 	nma_menu_add_separator_item (menu);
 
 	vpn_menu = GTK_MENU (gtk_menu_new ());
@@ -1606,19 +1625,21 @@ static void nma_menu_show_cb (GtkWidget
 
 	if (nm_client_get_state (applet->nm_client) == NM_STATE_ASLEEP) {
 		nma_menu_add_text_item (menu, _("Networking disabled"));
-		return;
-	}
-
-	nma_menu_add_devices (menu, applet);
-	nma_menu_add_vpn_submenu (menu, applet);
+	} else {
+		nma_menu_add_devices (menu, applet);
+		nma_menu_add_vpn_submenu (menu, applet);
 
-	if (has_usable_wifi (applet)) {
-		/* Add the "Hidden Wi-Fi network..." entry */
-		nma_menu_add_separator_item (menu);
-		nma_menu_add_hidden_network_item (menu, applet);
-		nma_menu_add_create_network_item (menu, applet);
+		if (has_usable_wifi (applet)) {
+			/* Add the "Hidden Wi-Fi network..." entry */
+			nma_menu_add_separator_item (menu);
+			nma_menu_add_hidden_network_item (menu, applet);
+			nma_menu_add_create_network_item (menu, applet);
+		}
 	}
 
+	nma_context_menu_create (applet);
+	nma_context_menu_update (applet);
+
 	if (!INDICATOR_ENABLED (applet))
 		gtk_widget_show_all (menu);
 }
@@ -1870,8 +1891,10 @@ static GtkWidget *nma_context_menu_creat
 				   applet);
 	gtk_menu_shell_append (menu, applet->connections_menu_item);
 
+#if 0 // disable About item
 	/* Separator */
 	nma_menu_add_separator_item (GTK_WIDGET (menu));
+#endif
 
 	if (!INDICATOR_ENABLED (applet)) {
 		/* About item */
@@ -2012,6 +2035,57 @@ applet_schedule_update_menu (NMApplet *a
 	}
 }
 
+typedef struct _MenuPosition
+{
+	unsigned int x;
+	unsigned int y;
+} MenuPosition;
+
+static void
+set_popup_position (GtkMenu *menu, gint *x, gint *y, gboolean *push_in, MenuPosition *menuPosition)
+{
+	*x = (gint)menuPosition->x;
+	*y = (gint)menuPosition->y;
+}
+
+static void
+popup_network_menu_cb (NMApplet  *agent, unsigned int x, unsigned int y, gpointer user_data)
+{
+	NMApplet *applet = NM_APPLET (user_data);
+	MenuPosition menuPosition;
+
+	menuPosition.x = x;
+	menuPosition.y = y;
+
+	applet_clear_notify (applet);
+	if (applet->menu)
+		g_object_unref (applet->menu);
+
+
+	/* And make a fresh new one */
+	applet->menu = gtk_menu_new ();
+	/* Sink the ref so we can explicitly destroy the menu later */
+	g_object_ref_sink (G_OBJECT (applet->menu));
+
+	gtk_container_set_border_width (GTK_CONTAINER (applet->menu), 0);
+	g_signal_connect (applet->menu, "show", G_CALLBACK (nma_menu_show_cb), applet);
+	g_signal_connect (applet->menu, "deactivate", G_CALLBACK (nma_menu_deactivate_cb), applet);
+
+	g_warning ("popup_network_menu");
+	/* Display the new menu */
+	gtk_menu_popup (GTK_MENU (applet->menu), NULL, NULL,
+			(GtkMenuPositionFunc)set_popup_position, (gpointer)&menuPosition,
+			1, gtk_get_current_event_time ());
+
+}
+
+static void
+close_network_menu_cb (NMApplet *agent, gpointer user_data)
+{
+	NMApplet *applet = NM_APPLET (user_data);
+	gtk_menu_popdown (GTK_MENU (applet->menu));
+}
+
 /*****************************************************************************/
 
 static void
@@ -3099,8 +3173,8 @@ status_icon_activate_cb (GtkStatusIcon *
 
 	/* Display the new menu */
 	gtk_menu_popup (GTK_MENU (applet->menu), NULL, NULL,
-	                gtk_status_icon_position_menu, icon,
-	                1, gtk_get_current_event_time ());
+			gtk_status_icon_position_menu, icon,
+			1, gtk_get_current_event_time ());
 }
 
 static void
@@ -3114,10 +3188,45 @@ status_icon_popup_menu_cb (GtkStatusIcon
 	 */
 	applet_clear_notify (applet);
 
+#if 0
 	nma_context_menu_update (applet);
 	gtk_menu_popup (GTK_MENU (applet->context_menu), NULL, NULL,
 			gtk_status_icon_position_menu, icon,
 			button, activate_time);
+#endif
+}
+
+
+static DBusHandlerResult
+menu_signal_filter(DBusConnection *connection, DBusMessage *message, gpointer user_data)
+{
+	if (dbus_message_is_signal(message, APPLET_MENU_SIGNAL_INTERFACE, APPLET_MENU_SIGNAL_MEMBER_POPUP)) {
+		if (user_data != NULL) {
+			unsigned int x;
+			unsigned int y;
+			NMApplet *applet = user_data;
+
+			if (applet != NULL) {
+				if (dbus_message_get_args(message, NULL,
+							DBUS_TYPE_UINT32, &x,
+							DBUS_TYPE_UINT32, &y,
+							DBUS_TYPE_INVALID)) {
+
+					g_signal_emit (applet, signals[POPUP_NETWORK_MENU], 0, x, y);
+				}
+			}
+		}
+	}
+
+	if (dbus_message_is_signal(message, APPLET_MENU_SIGNAL_INTERFACE, APPLET_MENU_SIGNAL_MEMBER_CLOSE)) {
+		NMApplet *applet = user_data;
+
+		if (applet != NULL) {
+			g_signal_emit (applet, signals[CLOSE_NETWORK_MENU], 0);
+		}
+	}
+
+	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 }
 
 static gboolean
@@ -3264,6 +3373,10 @@ applet_startup (GApplication *app, gpoin
 	if (!notify_is_initted ())
 		notify_init ("NetworkManager");
 
+	g_signal_connect (applet, APPLET_POPUP_NETWORK_MENU, G_CALLBACK (popup_network_menu_cb), applet);
+	g_signal_connect (applet, APPLET_CLOSE_NETWORK_MENU, G_CALLBACK (close_network_menu_cb), applet);
+
+
 	/* Initialize device classes */
 	applet->ethernet_class = applet_device_ethernet_get_class (applet);
 	g_assert (applet->ethernet_class);
Index: network-manager-applet-1.4.4/src/applet.h
===================================================================
--- network-manager-applet-1.4.4.orig/src/applet.h
+++ network-manager-applet-1.4.4/src/applet.h
@@ -43,6 +43,8 @@
 #include <libmm-glib.h>
 #endif
 
+#include <dbus/dbus.h>
+
 #define NM_TYPE_APPLET			(nma_get_type())
 #define NM_APPLET(object)		(G_TYPE_CHECK_INSTANCE_CAST((object), NM_TYPE_APPLET, NMApplet))
 #define NM_APPLET_CLASS(klass)	(G_TYPE_CHECK_CLASS_CAST((klass), NM_TYPE_APPLET, NMAppletClass))
@@ -52,6 +54,8 @@
 
 typedef struct {
 	GApplicationClass	parent_class;
+	void (*popup_network_menu) (AppletAgent *self, unsigned int x, unsigned int y);
+	void (*close_network_menu) (AppletAgent *self);
 } NMAppletClass; 
 
 #define APPLET_PREFS_SCHEMA "org.gnome.nm-applet"
@@ -66,6 +70,15 @@ typedef struct {
 #define ICON_LAYER_VPN 1
 #define ICON_LAYER_MAX ICON_LAYER_VPN
 
+#define APPLET_CLOSE_NETWORK_MENU "close-network-menu"
+#define APPLET_POPUP_NETWORK_MENU "popup-network-menu"
+
+#define APPLET_MENU_SIGNAL_RULE         "type='signal',interface='com.citrix.xenclient.xui'"
+#define APPLET_MENU_SIGNAL_INTERFACE    "com.citrix.xenclient.xui"
+#define APPLET_MENU_SIGNAL_MEMBER_POPUP "popup_network_menu"
+#define APPLET_MENU_SIGNAL_MEMBER_CLOSE "close_network_menu"
+
+
 typedef struct NMADeviceClass NMADeviceClass;
 
 /*
