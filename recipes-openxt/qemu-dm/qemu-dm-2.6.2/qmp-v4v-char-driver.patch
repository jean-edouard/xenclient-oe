Index: qemu-2.6.2/qemu-char.c
===================================================================
--- qemu-2.6.2.orig/qemu-char.c
+++ qemu-2.6.2/qemu-char.c
@@ -42,6 +42,7 @@
 #include "sysemu/replay.h"
 
 #include <zlib.h>
+#include <libv4v.h>
 
 #ifndef _WIN32
 #include <sys/times.h>
@@ -2488,6 +2489,299 @@ err1:
 
 
 /***********************************************************/
+/* V4V console for QMP */
+
+#define V4V_TYPE 'W'
+#define V4VIOCSETRINGSIZE       _IOW (V4V_TYPE,  1, uint32_t)
+
+#define V4V_QH_PORT 5100
+#define V4V_CHARDRV_PORT 15100
+#define V4V_CHARDRV_RING_SIZE \
+  (V4V_ROUNDUP((((4096)*4) - sizeof(v4v_ring_t)-V4V_ROUNDUP(1))))
+
+#define V4V_MAGIC_CONNECT    "live"
+#define V4V_MAGIC_DISCONNECT "dead"
+
+#define V4V_CHARDRV_NAME  "[v4v-chardrv]"
+
+typedef struct {
+    int fd;
+    int connection;
+    QIOChannel *ioc;
+    QIOChannel *iocmaster;
+    v4v_addr_t remote_addr;
+    v4v_addr_t local_addr;
+    uint8_t buf[READ_BUF_LEN];
+    int bufcnt;
+    int bufptr;
+    int max_size;
+} V4vCharDriver;
+
+static int v4v_chr_write(CharDriverState *chr, const uint8_t *buf, int len)
+{
+    V4vCharDriver *s = chr->opaque;
+    int ret;
+
+    ret = v4v_send(s->connection, buf, len, 0);
+    if (ret != len) {
+        fprintf(stderr, "%s error: v4v_send() failed (%s) - %d %d.\n",
+                V4V_CHARDRV_NAME, strerror(errno), ret, len);
+        return 0;
+    }
+
+    return ret;
+}
+
+static int v4v_chr_read_poll(void *opaque)
+{
+    CharDriverState *chr = opaque;
+    V4vCharDriver *s = chr->opaque;
+
+    if (s->connection < 0)
+        return 0;
+
+    s->max_size = qemu_chr_be_can_write(chr);
+
+    /* If there were any stray characters in the queue process them
+     * first
+     */
+    while (s->max_size > 0 && s->bufptr < s->bufcnt) {
+        qemu_chr_be_write(chr, &s->buf[s->bufptr], 1);
+        s->bufptr++;
+        s->max_size = qemu_chr_be_can_write(chr);
+    }
+    return s->max_size;
+}
+
+static gboolean v4v_chr_read(QIOChannel *chan, GIOCondition cond, void *opaque);
+
+static int v4v_chr_accept_poll(void *opaque)
+{
+    CharDriverState *chr = opaque;
+    V4vCharDriver *s = chr->opaque;
+    fd_set set;
+    struct timeval timeout;
+    int rv;
+
+    /* If a connection is open, no need to poll the master fd */
+    if (s->connection > 0)
+        return 0;
+
+    FD_ZERO(&set);
+    FD_SET(s->fd, &set);
+    timeout.tv_sec = 0;
+    timeout.tv_usec = 0;
+    rv = select(s->fd + 1, &set, NULL, NULL, &timeout);
+
+    return rv;
+}
+
+static gboolean v4v_chr_accept(QIOChannel *chan, GIOCondition cond, void *opaque);
+
+static void v4v_chr_update_read_handler(CharDriverState *chr)
+{
+    V4vCharDriver *s = chr->opaque;
+
+    remove_fd_in_watch(chr);
+    if (s->iocmaster) {
+        chr->fd_in_tag = io_add_watch_poll(s->iocmaster,
+                                           v4v_chr_accept_poll,
+                                           v4v_chr_accept, chr);
+    }
+    if (s->ioc) {
+        chr->fd_in_tag = io_add_watch_poll(s->ioc,
+                                           v4v_chr_read_poll,
+                                           v4v_chr_read, chr);
+    }
+}
+
+static gboolean v4v_chr_accept(QIOChannel *chan, GIOCondition cond, void *opaque)
+{
+    CharDriverState *chr = opaque;
+    V4vCharDriver *s = chr->opaque;
+    v4v_addr_t peer;
+
+    /* If we don't have an active connection, it means listen() triggered on s->fd */
+    if (s->connection < 0) {
+        s->connection = v4v_accept(s->fd, &peer);
+        if (s->connection < 0) {
+            fprintf(stderr, "%s error: v4v_accept() failed (%s) - %d.\n",
+                    V4V_CHARDRV_NAME, strerror(errno), s->connection);
+            v4v_close(s->connection);
+            s->connection = -1;
+            return FALSE;
+        }
+        if (peer.port != s->remote_addr.port || peer.domain != s->remote_addr.domain) {
+            fprintf(stderr, "JED FAILED\n");
+            v4v_close(s->connection);
+            s->connection = -1;
+            return FALSE;
+        }
+        fprintf(stderr, "JED CONNECTED\n");
+        s->ioc = QIO_CHANNEL(qio_channel_file_new_fd(s->connection));
+        v4v_chr_update_read_handler(chr);
+        qemu_chr_be_generic_open(chr);
+
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+static gboolean v4v_chr_read(QIOChannel *chan, GIOCondition cond, void *opaque)
+{
+    CharDriverState *chr = opaque;
+    V4vCharDriver *s = chr->opaque;
+    int ret;
+
+    if (s->connection < 0)
+        return 0;
+
+    /* If we are here, s->connection triggered the watch */
+    if (s->max_size == 0)
+        return FALSE;
+    ret = v4v_recv(s->connection, s->buf, sizeof(s->buf), 0);
+    if (ret < 0) {
+        fprintf(stderr, "%s error: v4v_recv() failed (%s) - %d.\n",
+                V4V_CHARDRV_NAME, strerror(errno), ret);
+        s->connection = -1;
+        v4v_chr_update_read_handler(chr);
+        qemu_chr_be_event(chr, CHR_EVENT_CLOSED);
+        return FALSE;
+    }
+    if (ret == 0) {
+        fprintf(stderr, "v4v_recv() returned 0, closing.\n");
+        v4v_close(s->connection);
+        s->connection = -1;
+        v4v_chr_update_read_handler(chr);
+        qemu_chr_be_event(chr, CHR_EVENT_CLOSED);
+        return FALSE;
+    }
+    if (!strncmp((char*)(s->buf), V4V_MAGIC_CONNECT, 4)) {
+        v4v_chr_update_read_handler(chr);
+        qemu_chr_be_event(chr, CHR_EVENT_OPENED);
+        return FALSE;
+    }
+    if (!strncmp((char*)(s->buf), V4V_MAGIC_DISCONNECT, 4)) {
+        v4v_chr_update_read_handler(chr);
+        qemu_chr_be_event(chr, CHR_EVENT_CLOSED);
+        return FALSE;
+    }
+
+    s->bufcnt = ret;
+    s->bufptr = 0;
+    while (s->max_size > 0 && s->bufptr < s->bufcnt) {
+        qemu_chr_be_write(chr, &s->buf[s->bufptr], 1);
+        s->bufptr++;
+        s->max_size = qemu_chr_be_can_write(chr);
+    }
+
+    return TRUE;
+}
+
+static GSource *v4v_chr_add_watch(CharDriverState *chr, GIOCondition cond)
+{
+    V4vCharDriver *s = chr->opaque;
+    return qio_channel_create_watch(s->ioc, cond);
+}
+
+static void v4v_chr_close(CharDriverState *chr)
+{
+    V4vCharDriver *s = chr->opaque;
+
+    /* TODO should call close() internally on v4v fd */
+    remove_fd_in_watch(chr);
+
+    if (s->ioc) {
+        object_unref(OBJECT(s->ioc));
+    }
+
+    v4v_close(s->connection);
+    v4v_close(s->fd);
+    s->connection = -1;
+    s->fd = -1;
+
+    g_free(s);
+
+    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);
+}
+
+static CharDriverState *qemu_chr_open_v4v(const char *id,
+                                          ChardevBackend *backend,
+                                          ChardevReturn *ret,
+                                          Error **errp)
+{
+    CharDriverState *chr = NULL;
+    V4vCharDriver *s = NULL;
+    ChardevCommon *common = backend->u.v4v.data;
+    uint32_t v4v_ring_size = V4V_CHARDRV_RING_SIZE;
+    int fd = -1;
+
+    s = g_new0(V4vCharDriver, 1);
+
+    s->local_addr.port = V4V_CHARDRV_PORT;
+    s->local_addr.domain = V4V_DOMID_ANY;
+    s->remote_addr.port = V4V_QH_PORT;
+    s->remote_addr.domain = 0;
+
+    fd = v4v_socket(SOCK_STREAM);
+    if (fd < 0) {
+        error_setg(errp, "%s cannot create v4v socket - err: %d",
+                   V4V_CHARDRV_NAME, fd);
+        return NULL;
+    }
+
+    if (ioctl(fd, V4VIOCSETRINGSIZE, &v4v_ring_size)) {
+        error_setg(errp,
+                   "%s failed to set ring size v4v socket - err: %d",
+                   V4V_CHARDRV_NAME, errno);
+        close(fd);
+        return NULL;
+    }
+
+    if (v4v_bind(fd, &s->local_addr, 0)) {
+        error_setg(errp,
+                   "%s failed to bind v4v socket - err: %d",
+                   V4V_CHARDRV_NAME, errno);
+        close(fd);
+        return NULL;
+    }
+
+    if (v4v_listen(fd, 1)) {
+        error_setg(errp,
+                   "%s failed to listen on v4v socket - err: %d",
+                   V4V_CHARDRV_NAME, errno);
+        close(fd);
+        return NULL;
+    }
+
+    chr = qemu_chr_alloc(common, errp);
+    if (!chr) {
+        close(fd);
+        return NULL;
+    }
+
+    s->fd = fd;
+    s->connection = -1;
+    s->bufcnt = 0;
+    s->bufptr = 0;
+    chr->opaque = s;
+    chr->chr_write = v4v_chr_write;
+    chr->chr_update_read_handler = v4v_chr_update_read_handler;
+    chr->chr_close = v4v_chr_close;
+    chr->chr_add_watch = v4v_chr_add_watch;
+    /* be isn't opened until we get a connection */
+    chr->explicit_be_open = true;
+
+    s->iocmaster = QIO_CHANNEL(qio_channel_file_new_fd(fd));
+    s->ioc = NULL;
+
+    fprintf(stderr, "Opened V4V chardev\n");
+
+    return chr;
+}
+
+/***********************************************************/
 /* UDP Net console */
 
 typedef struct {
@@ -3430,6 +3724,7 @@ QemuOpts *qemu_chr_parse_compat(const ch
         strcmp(filename, "pty")     == 0 ||
         strcmp(filename, "msmouse") == 0 ||
         strcmp(filename, "braille") == 0 ||
+        strcmp(filename, "v4v")     == 0 ||
         strcmp(filename, "testdev") == 0 ||
         strcmp(filename, "stdio")   == 0) {
         qemu_opt_set(opts, "backend", filename, &error_abort);
@@ -4542,6 +4837,17 @@ out_error:
     return NULL;
 }
 
+static bool qemu_chr_is_busy(CharDriverState *chr)
+{
+    if (chr->is_mux) {
+        MuxDriver *d = chr->opaque;
+        return d->mux_cnt >= 0;
+    } else {
+        return (chr->chr_can_read || chr->chr_read ||
+                chr->chr_event || chr->handler_opaque);
+    }
+}
+
 void qmp_chardev_remove(const char *id, Error **errp)
 {
     CharDriverState *chr;
@@ -4551,8 +4857,7 @@ void qmp_chardev_remove(const char *id,
         error_setg(errp, "Chardev '%s' not found", id);
         return;
     }
-    if (chr->chr_can_read || chr->chr_read ||
-        chr->chr_event || chr->handler_opaque) {
+    if (qemu_chr_is_busy(chr)) {
         error_setg(errp, "Chardev '%s' is busy", id);
         return;
     }
@@ -4605,6 +4910,8 @@ static void register_types(void)
     /* Bug-compatibility: */
     register_char_driver("memory", CHARDEV_BACKEND_KIND_MEMORY,
                          qemu_chr_parse_ringbuf, qemu_chr_open_ringbuf);
+    register_char_driver("v4v", CHARDEV_BACKEND_KIND_V4V, NULL,
+                         qemu_chr_open_v4v);
     /* this must be done after machine init, since we register FEs with muxes
      * as part of realize functions like serial_isa_realizefn when -nographic
      * is specified
Index: qemu-2.6.2/qapi-schema.json
===================================================================
--- qemu-2.6.2.orig/qapi-schema.json
+++ qemu-2.6.2/qapi-schema.json
@@ -3362,7 +3362,8 @@
                                        'vc'     : 'ChardevVC',
                                        'ringbuf': 'ChardevRingbuf',
                                        # next one is just for compatibility
-                                       'memory' : 'ChardevRingbuf' } }
+                                       'memory' : 'ChardevRingbuf',
+                                       'v4v' : 'ChardevCommon' } }
 
 ##
 # @ChardevReturn:
