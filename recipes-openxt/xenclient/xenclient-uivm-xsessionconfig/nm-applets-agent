#!/bin/bash

# Usage: nwd_list_backends
#   List dbus-path for NetworkManager backends avaiable on stdout.
#   Format seems consistently: /ndvm/<uuid>
nwd_list_backends() {
    local dest="com.citrix.xenclient.networkdaemon"
    local intf="com.citrix.xenclient.networkdaemon.list_backends"
    local path="/"
    # Contact dom0 rpc-proxy and parse the answer.
    DBUS_SYSTEM_BUS_ADDRESS=tcp:host=1.0.0.0,port=5555 \
    LD_PRELOAD=/usr/lib/libv4v-1.0.so.0 \
    INET_IS_V4V=1 \
        dbus-send --system --print-reply --dest="${dest}" "${path}" "${intf}" \
        | sed -ne 's|.*string "\(.\+\)".*|\1|p'
}

# Usage: networkdomain_config_get_string dbus-path arg
#   Print the requested configuration (arg) for the given network domain on stdout.
networkdomain_config_get_string() {
    local path="$1"
    local arg="$2"
    local dest="com.citrix.xenclient.networkdaemon"
    local intf="org.freedesktop.DBus.Properties.Get"

    DBUS_SYSTEM_BUS_ADDRESS=tcp:host=1.0.0.0,port=5555 \
    LD_PRELOAD=/usr/lib/libv4v-1.0.so.0 \
    INET_IS_V4V=1 \
        dbus-send --system --print-reply --dest="${dest}" "${path}" "${intf}" \
            string:"com.citrix.xenclient.networkdomain.config" \
            string:"${arg}" \
        | sed -ne 's|.*string "\(.\+\)".*|\1|p'
}

# Usage: networkdomain_config_get_uint32 dbus-path arg
#   Print the requested configuration (arg) for the given network domain on stdout.
networkdomain_config_get_uint32() {
    local path="$1"
    local arg="$2"
    local dest="com.citrix.xenclient.networkdaemon"
    local intf="org.freedesktop.DBus.Properties.Get"

    DBUS_SYSTEM_BUS_ADDRESS=tcp:host=1.0.0.0,port=5555 \
    LD_PRELOAD=/usr/lib/libv4v-1.0.so.0 \
    INET_IS_V4V=1 \
        dbus-send --system --print-reply --dest="${dest}" "${path}" "${intf}" \
            string:"com.citrix.xenclient.networkdomain.config" \
            string:"${arg}" \
        | sed -ne 's|.*uint32 \([0-9]\+\).*|\1|p'
}

# Usage: networkdomain_monitor interface member
#   Watch for changes signaled by network-daemon for the given (interface, member).
#   Since connection to the remote DBus is direct, sender is not filtered,
#   which leaves some noise on the output.
networkdomain_monitor_signal() {
    local intf="com.citrix.xenclient.networkdomain.notify"
    local member="backend_state_changed"

    DBUS_SYSTEM_BUS_ADDRESS=tcp:host=1.0.0.0,port=5555 \
    LD_PRELOAD=/usr/lib/libv4v-1.0.so.0 \
    INET_IS_V4V=1 \
        dbus-monitor --system --profile "type='signal',interface='${intf}',member='${member}'"
}

# Usage nm_applet_pidfile dbus-path
#   Write pidfile path to track nm-applet running for backend with dbus-path on
#   stdout.
nm_applet_pidfile() {
    local dbus_path="$1"
    echo "/run/nm-applet-${dbus_path//\//-}.pid"
}

# Usage: start_nm_applet dbus-path
#   Start nm-applet, in configured environment for dbus-path NetworkDomain and
#   reccord a pidfile for process management.
start_nm_applet() {
    local dbus_path="$1"
    local uuid="$(networkdomain_config_get_string ${dbus_path} uuid)"
    local domid="$(networkdomain_config_get_uint32 ${dbus_path} domid)"
    local name="$(networkdomain_config_get_string ${dbus_path} name)"
    local pidfile="$(nm_applet_pidfile ${dbus_path})"

    if [ -z "${uuid}" ]; then
        echo "Invalid UUID:${uuid} for nm-applet." >&2
        return 1
    fi
    if [ -z "${domid}" ]; then
        echo "Invalid domid:${domid} for nm-applet." >&2
        return 1
    fi
    if [ -z "${name}" ]; then
        echo "Invalid name:${name} for nm-applet." >&2
        return 1
    fi
    if [ -e "${pidfile}" ]; then
        if pgrep -F "${pidfile}" >/dev/null; then
            echo "nm-applet already running for UUID:${uuid}" >&2
            return 1
        else
            echo "Spurious pidfile found for nm-applet UUID:${uuid}" >&2
            rm -f ${pidfile}
        fi
    fi

    env \
        INET_IS_V4V=1 \
        DBUS_SYSTEM_BUS_ADDRESS="tcp:host=1.0.0.${domid},port=5555" \
        LD_PRELOAD="/usr/lib/libv4v-1.0.so.0" \
        DEFAULT_CERTS_DIR="/var/lib/NetworkManager/${name}" \
            nm-applet "${uuid}" &
    echo $! > "${pidfile}"
}

# Usage: _stop_nm_applet pidfile
_stop_nm_applet() {
    local pidfile="$1"

    pkill -F "${pidfile}"
    rm -f "${pidfile}"
}

# Usage: stop_nm_applet dbus-path
#   Stop nm-applet running for the Network backend refered to by dbus-path.
stop_nm_applet() {
    local dbus_path="$1"
    local pidfile="$(nm_applet_pidfile ${dbus_path})"

    _stop_nm_applet "${pidfile}"
}

# Usage: start_all_nm_applets
#   Start all nm-applets instances, one for each present backend.
start_all_nm_applets() {
    for p in $(nwd_list_backends); do
        start_nm_applet "${p}"
    done
}

# Usage: stop_all_nm_applets
#   Stop all nm-applets instances.
stop_all_nm_applets() {
    for pidfile in /run/nm-applet-*.pid; do
        _stop_nm_applet "${pidfile}"
    done
}

# Usage: monitor_nm_applets
#   Listen to Network daemon on DBus for NetworkManager changes in backend
#   domains.
monitor_nm_applets() {
    # Launcher event loop.
    local nwd_notify_intf="com.citrix.xenclient.networkdomain.notify"
    local nwd_state_member="backend_state_changed"

    while read type _ _ _ _ path intf member ; do
        # Ignore spurious signals.
        if [ "${type}" != "sig" -o \
             "${intf}" != "${nwd_notify_intf}" -o \
             "${member}" != "${nwd_state_member}" ]; then
            continue
        fi

        local state="off"
        for p in $(nwd_list_backends); do
            if [ "${p}" = "${path}" ]; then
                state="on"
                break
            fi
        done
        case "${state}" in
            "on")   start_nm_applet "${path}" ;;
            "off")  stop_nm_applet "${path}" ;;
        esac

    done < <( networkdomain_monitor_signal "${nwd_notify_intf}" "${nwd_state_member}" )
}

## Start an nm-applet for every backend.
start_all_nm_applets

## Monitor nm-applets
monitor_nm_applets

## This should only happen when X stops, or something went terribly...
stop_all_nm_applets
