From ae9d5ed56b1c4c1dc076506708439047b2efe56b Mon Sep 17 00:00:00 2001
From: Eric Chanudet <chanudete@ainfosec.com>
Date: Thu, 17 Jan 2019 17:20:47 -0500
Subject: [PATCH 16/18] pcr-calc: Switch to safestringlib.

Other tools provided with tboots moved to safestringlib.
Do so and change the callsites of relevant functions accordingly.

The sources ship with safestringlib 1.0.0.

https://github.com/intel/safestringlib

Signed-off-by: Eric Chanudet <chanudete@ainfosec.com>
---
 pcr-calc/Makefile      |  2 +-
 pcr-calc/hash.c        | 52 +++++++++++++++++++++++++++++-------------
 pcr-calc/module_hash.c |  5 ++--
 pcr-calc/tb_policy.c   |  5 ++--
 pcr-calc/tpm.c         | 51 ++++++++++++++++++++++++++---------------
 5 files changed, 76 insertions(+), 39 deletions(-)

diff --git a/pcr-calc/Makefile b/pcr-calc/Makefile
index 25e0591..e49102d 100644
--- a/pcr-calc/Makefile
+++ b/pcr-calc/Makefile
@@ -15,7 +15,7 @@ TARGETS := pcr-calc module_hash
 
 CFLAGS += -D_LARGEFILE64_SOURCE
 
-LIBS += -lcrypto -lz
+LIBS += -lcrypto -lz $(ROOTDIR)/safestringlib/libsafestring.a
 
 ifdef HAVE_BZIP
 BZIP_LIB := -lbz2
diff --git a/pcr-calc/hash.c b/pcr-calc/hash.c
index 689d4cc..6369526 100644
--- a/pcr-calc/hash.c
+++ b/pcr-calc/hash.c
@@ -38,6 +38,7 @@
 #include <stdint.h>
 #include <stdbool.h>
 #include <string.h>
+#include <safe_lib.h>
 #include <openssl/evp.h>
 #define PRINT   printf
 #include "../include/config.h"
@@ -52,21 +53,38 @@
 bool are_hashes_equal(const tb_hash_t *hash1, const tb_hash_t *hash2,
 		      uint16_t hash_alg)
 {
+    int diff;
+    errno_t err;
+    rsize_t len;
+
     if ( ( hash1 == NULL ) || ( hash2 == NULL ) )
         return false;
 
-    if ( hash_alg == TB_HALG_SHA1 )
-        return (memcmp(hash1, hash2, SHA1_LENGTH) == 0);
-    else if ( hash_alg == TB_HALG_SHA256 )
-        return (memcmp(hash1, hash2, SHA256_LENGTH) == 0);
-    else if ( hash_alg == TB_HALG_SM3 )
-        return (memcmp(hash1, hash2, SM3_LENGTH) == 0);
-    else if ( hash_alg == TB_HALG_SHA384 )
-        return (memcmp(hash1, hash2, SHA384_LENGTH) == 0);
-    else if ( hash_alg == TB_HALG_SHA512 )
-        return (memcmp(hash1, hash2, SHA512_LENGTH) == 0);
-    else
+    switch ( hash_alg ) {
+        case TB_HALG_SHA1:
+            len = SHA1_LENGTH;
+            break;
+        case TB_HALG_SHA256:
+            len = SHA256_LENGTH;
+            break;
+        case TB_HALG_SM3:
+            len = SM3_LENGTH;
+            break;
+        case TB_HALG_SHA384:
+            len = SHA384_LENGTH;
+            break;
+        case TB_HALG_SHA512:
+            len = SHA512_LENGTH;
+            break;
+        default:
+            return false;
+    }
+
+    err = memcmp_s(hash1, sizeof(tb_hash_t), hash2, len, &diff);
+    if ( err )
         return false;
+
+    return !diff;
 }
 
 /*
@@ -137,8 +155,9 @@ bool extend_hash(tb_hash_t *hash1, const tb_hash_t *hash2, uint16_t hash_alg)
         return false;
 
     if ( hash_alg == TB_HALG_SHA1 ) {
-        memcpy(buf, &(hash1->sha1), sizeof(hash1->sha1));
-        memcpy(buf + sizeof(hash1->sha1), &(hash2->sha1), sizeof(hash1->sha1));
+        memcpy_s(buf, sizeof(buf), &(hash1->sha1), sizeof(hash1->sha1));
+        memcpy_s(buf + sizeof(hash1->sha1), sizeof(buf) - sizeof(hash1->sha1),
+                 &(hash2->sha1), sizeof(hash1->sha1));
         md = EVP_sha1();
         EVP_DigestInit(ctx, md);
         EVP_DigestUpdate(ctx, buf, 2*sizeof(hash1->sha1));
@@ -146,8 +165,9 @@ bool extend_hash(tb_hash_t *hash1, const tb_hash_t *hash2, uint16_t hash_alg)
         ret = true;
     }
     else if (hash_alg == TB_HALG_SHA256) {
-        memcpy(buf, &(hash1->sha256), sizeof(hash1->sha256));
-        memcpy(buf + sizeof(hash1->sha256), &(hash2->sha256), sizeof(hash1->sha256));
+        memcpy_s(buf, sizeof(buf), &(hash1->sha256), sizeof(hash1->sha256));
+        memcpy_s(buf + sizeof(hash1->sha256), sizeof(buf) - sizeof(hash1->sha256),
+                 &(hash2->sha256), sizeof(hash1->sha256));
         md = EVP_sha256();
         EVP_DigestInit(ctx, md);
         EVP_DigestUpdate(ctx, buf, 2*sizeof(hash1->sha256));
@@ -197,7 +217,7 @@ void copy_hash(tb_hash_t *dest_hash, const tb_hash_t *src_hash,
 
     len = get_hash_size(hash_alg);
     if ( len > 0 )
-        memcpy(dest_hash, src_hash, len);
+        memcpy_s(dest_hash, sizeof(tb_hash_t), src_hash, len);
     else
         printf("unsupported hash alg (%u)\n", hash_alg);
 }
diff --git a/pcr-calc/module_hash.c b/pcr-calc/module_hash.c
index 4cf1579..4abd6ad 100644
--- a/pcr-calc/module_hash.c
+++ b/pcr-calc/module_hash.c
@@ -40,6 +40,7 @@
 #include <stdint.h>
 #include <stdarg.h>
 #include <getopt.h>
+#include <safe_lib.h>
 #include <zlib.h>
 #include <sys/stat.h>
 #include <openssl/evp.h>
@@ -170,7 +171,7 @@ static bool read_module(const char *path, char **buffer, size_t *len, uint8_t fl
 	*buffer = malloc(*len);
 	if (*buffer == NULL)
 		goto fail_tmp;
-	memset(*buffer, 0, *len);
+	memset_s(*buffer, *len, 0);
 
 	if (fread(*buffer, 1, *len, tmpfd) != *len)
 		goto fail_buf;
@@ -283,7 +284,7 @@ static bool read_hash(const char *hexstr, tb_hash_t *hash, uint16_t hash_alg)
 	}
 
 	if (len == 1 && hexstr[0] == '0') {
-		memset(buf, 0, hash_length);
+		memset_s(buf, hash_length, 0);
 		return true;
 	}
 
diff --git a/pcr-calc/tb_policy.c b/pcr-calc/tb_policy.c
index 4f39ae6..4215342 100644
--- a/pcr-calc/tb_policy.c
+++ b/pcr-calc/tb_policy.c
@@ -38,6 +38,7 @@
 #include <stdbool.h>
 #include <stdlib.h>
 #include <string.h>
+#include <safe_lib.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
@@ -61,8 +62,8 @@ tb_hash_t *tb_policy_hash(tb_policy_t *pol, size_t size, uint16_t alg)
 	if (!hash)
 		goto out;
 
-	memset(buf, 0, sizeof(buf));
-	memcpy(buf, &pol->policy_control, sizeof(pol->policy_control));
+	memset_s(buf, sizeof(buf), 0);
+	memcpy_s(buf, sizeof(buf), &pol->policy_control, sizeof(pol->policy_control));
 
 	if ( pol->policy_control & TB_POLCTL_EXTEND_PCR17 )
 		if ( !hash_buffer((unsigned char *)pol, size,
diff --git a/pcr-calc/tpm.c b/pcr-calc/tpm.c
index 58b63b9..fb7d501 100644
--- a/pcr-calc/tpm.c
+++ b/pcr-calc/tpm.c
@@ -34,7 +34,8 @@
 
 #include <stdio.h>
 #include <stdlib.h>
-#include <memory.h>
+#include <string.h>
+#include <safe_lib.h>
 #include <stdbool.h>
 #include <stdint.h>
 #include <stdarg.h>
@@ -76,7 +77,7 @@ bool pcr_recalculate(struct pcr *p, uint16_t alg)
 	if (p->log_idx == 0)
 		return true;
 
-	memset(&p->value, 0, sizeof(tb_hash_t));
+	memset_s(&p->value, sizeof(tb_hash_t), 0);
 
 	for (i = 0; i < p->log_idx; i++) {
 		struct pcr_event *e = &p->log[i];
@@ -85,11 +86,11 @@ bool pcr_recalculate(struct pcr *p, uint16_t alg)
 
 		if (e->type == TPM_EVT_HASH_START) {
 			if (extend_hash_start()) {
-				memset(&p->value, 0, sizeof(tb_hash_t));
+				memset_s(&p->value, sizeof(tb_hash_t), 0);
 				if (!extend_hash(&p->value, &e->digest, alg))
 					return false;
 			} else {
-				memcpy(&p->value, &e->digest, sizeof(tb_hash_t));
+				memcpy_s(&p->value, sizeof(tb_hash_t), &e->digest, sizeof(tb_hash_t));
 			}
 		} else if (!extend_hash(&p->value, &e->digest, alg)) {
 			return false;
@@ -115,7 +116,7 @@ bool pcr_record_event(struct pcr *p, uint16_t alg, uint32_t type,
 
 	if (type == TPM_EVT_HASH_START) {
 		if (extend_hash_start()) {
-			memset(&p->value, 0, sizeof(tb_hash_t));
+			memset_s(&p->value, sizeof(tb_hash_t), 0);
 			if (!extend_hash(&p->value, hash, alg)) {
 				error_msg("failed to extend PCR%d with hash\n",
 					p->num);
@@ -123,7 +124,7 @@ bool pcr_record_event(struct pcr *p, uint16_t alg, uint32_t type,
 			}
 
 		} else {
-			memcpy(&p->value, hash, sizeof(tb_hash_t));
+			memcpy_s(&p->value, sizeof(tb_hash_t), hash, sizeof(tb_hash_t));
 		}
 	} else if (!extend_hash(&p->value, hash, alg)) {
 		error_msg("failed to extend PCR%d with hash\n", p->num);
@@ -132,7 +133,7 @@ bool pcr_record_event(struct pcr *p, uint16_t alg, uint32_t type,
 
 	evt = &p->log[p->log_idx];
 	evt->type = type;
-	memcpy(&evt->digest, hash, sizeof(tb_hash_t));
+	memcpy_s(&evt->digest, sizeof(tb_hash_t), hash, sizeof(tb_hash_t));
 	p->log_idx++;
 
 	return true;
@@ -329,7 +330,7 @@ bool tpm_clear_all_event(struct tpm *t, uint16_t alg, uint32_t evt_type)
 
 		for (j = 0; j < p->log_idx; j++) {
 			if (p->log[j].type == evt_type)
-				memset(&p->log[j], 0, sizeof(struct pcr_event));
+				memset_s(&p->log[j], sizeof(struct pcr_event), 0);
 		}
 	}
 
@@ -366,17 +367,24 @@ void tpm_print(struct tpm *t, uint16_t alg)
 	struct pcr_bank *bank;
 	tb_hash_t null_hash;
 
-	if (!t) {
+	if (!t)
 		return;
-	}
 
 	bank = &(t->banks[bnum]);
 
-	memset(&null_hash, 0, sizeof(tb_hash_t));
+	memset_s(&null_hash, sizeof(tb_hash_t), 0);
 
 	for (i = 0; i < MAX_PCR; i++) {
-		if (memcmp(&(bank->pcrs[i].value),
-		    &null_hash, sizeof(tb_hash_t)) == 0)
+		int diff;
+		errno_t err;
+
+		err = memcmp_s(&(bank->pcrs[i].value), sizeof(tb_hash_t),
+				&null_hash, sizeof(tb_hash_t), &diff);
+		if (err) {
+			error_msg("Invalid value in PCR%d.", i);
+			break;
+		}
+		if (!diff)
 			continue;
 
 		printf("%02d:",bank->pcrs[i].num);
@@ -390,17 +398,24 @@ void tpm_dump(struct tpm *t, uint16_t alg)
 	struct pcr_bank *bank;
 	tb_hash_t null_hash;
 
-	if (!t) {
+	if (!t)
 		return;
-	}
 
 	bank = &(t->banks[bnum]);
 
-	memset(&null_hash, 0, sizeof(tb_hash_t));
+	memset_s(&null_hash, sizeof(tb_hash_t), 0);
 
 	for (i = 0; i < MAX_PCR; i++) {
-		if (memcmp(&bank->pcrs[i].value,
-		    &null_hash, sizeof(tb_hash_t)) == 0)
+		int diff;
+		errno_t err;
+
+		err = memcmp_s(&(bank->pcrs[i].value), sizeof(tb_hash_t),
+				&null_hash, sizeof(tb_hash_t), &diff);
+		if (err) {
+			error_msg("Invalid value in PCR%d.", i);
+			break;
+		}
+		if (!diff)
 			continue;
 
 		pcr_print(&bank->pcrs[i], alg);
-- 
2.20.1

