From b4b8b342f76ff8115dcbfeea7324a42d66c50eab Mon Sep 17 00:00:00 2001
From: Eric Chanudet <chanudete@ainfosec.com>
Date: Thu, 7 Mar 2019 17:08:43 -0500
Subject: [PATCH 7/8] pcr-calc: Add 0x40f event emulation.

Different versions of TBoot may calculate some events differently
changing the final PCR values. Forward-sealing requires accurate
predictions of these values, introduce the scafolding to support such
emulation and allow the pcr-calc util to forward seal against a
different version of TBoot using a possibly different ACM.

Add 2 options to pcr-calc and modify existing `-e`:
    -e evt_type:<hash_str>|emulate Override PCR events type found in the
       logs with the provided value or emulate the value entirely
       (emulation requires TBoot version and ACM to be provided).

    -A acm-path Path to the ACM that will be used to emulate events for
       PCR calculations (see -e).

    -V tboot-version TBoot version targeted to emulate events for PCR
       calculations (see -e).

Signed-off-by: Eric Chanudet <chanudete@ainfosec.com>
---
 pcr-calc/Makefile   |   2 +-
 pcr-calc/acm.c      | 216 ++++++++++++++++++++++++++++++++++++++++++++
 pcr-calc/acm.h      | 134 +++++++++++++++++++++++++++
 pcr-calc/eventlog.c | 175 ++++++++++++++++++++++++++++++++++-
 pcr-calc/eventlog.h |  18 ++++
 pcr-calc/pcr-calc.c |  47 +++++++++-
 pcr-calc/tpm.c      |  58 ++++++++++++
 pcr-calc/tpm.h      |  14 +++
 pcr-calc/util.c     |  30 +++++-
 pcr-calc/util.h     |   5 +-
 10 files changed, 690 insertions(+), 9 deletions(-)
 create mode 100644 pcr-calc/acm.c
 create mode 100644 pcr-calc/acm.h

diff --git a/pcr-calc/Makefile b/pcr-calc/Makefile
index e49102d..7b06c5a 100644
--- a/pcr-calc/Makefile
+++ b/pcr-calc/Makefile
@@ -60,7 +60,7 @@ distclean : clean
 BUILD_DEPS := $(ROOTDIR)/Config.mk $(CURDIR)/Makefile
 
 
-pcr-calc : eventlog.o pcr-calc.o tpm.o util.o hash.o tb_policy.o
+pcr-calc : acm.o eventlog.o pcr-calc.o tpm.o util.o hash.o tb_policy.o
 	$(CC) $(CFLAGS) $(LDFLAGS) $^ $(LIBS) -o $@
 
 module_hash : module_hash.o hash.o
diff --git a/pcr-calc/acm.c b/pcr-calc/acm.c
new file mode 100644
index 0000000..56e76b2
--- /dev/null
+++ b/pcr-calc/acm.c
@@ -0,0 +1,216 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <string.h>
+#include <inttypes.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+
+#include "uuid.h"
+#include "acm.h"
+
+#define DEBUG 0
+#define printd(fmt, ...)					\
+	if (DEBUG) {						\
+		fprintf(stdout, fmt "\n", ##__VA_ARGS__);	\
+	}
+
+static acm_hdr_t *get_acm_header(void *p)
+{
+	uint32_t ovf;
+	acm_hdr_t *hdr = p;
+
+	if (__builtin_umul_overflow(hdr->size, 4, &ovf))
+		return NULL;
+	if (hdr->module_type != ACM_TYPE_CHIPSET)
+		return NULL;
+	if (hdr->module_vendor != ACM_VENDOR_INTEL)
+		return NULL;
+
+	return hdr;
+}
+
+static acm_info_table_t *get_acm_info_table(const acm_hdr_t *hdr)
+{
+	uint32_t ovf;
+	uint32_t offset;
+	acm_info_table_t *infotable;
+
+	/* Check infotable is in ACM. */
+	if (__builtin_uadd_overflow(hdr->header_len, hdr->scratch_size, &ovf))
+		return NULL;
+	if (__builtin_umul_overflow(hdr->header_len + hdr->scratch_size, 4, &ovf))
+		return NULL;
+	if ((hdr->header_len + hdr->scratch_size) * 4 > (hdr->size * 4))
+		return NULL;
+
+	offset = (hdr->header_len + hdr->scratch_size) * 4;
+
+	/* Check infotable does not outbound ACM. */
+	if (__builtin_uadd_overflow(offset, sizeof (*infotable), &ovf))
+		return NULL;
+	if (offset + sizeof (*infotable) > hdr->size * 4)
+		return NULL;
+
+	return (acm_info_table_t *)((void *)hdr + offset);
+}
+
+static acm_processor_id_list_t *get_acm_processor_list(const acm_hdr_t *hdr,
+		const acm_info_table_t *infotable)
+{
+	uint32_t ovf;
+	uint32_t offset;
+	acm_processor_id_list_t *proclist;
+
+	offset = infotable->processor_id_list;
+	proclist = (acm_processor_id_list_t *)((void *)hdr + offset);
+
+	/* Check proclist is contained in ACM size. */
+	if (__builtin_umul_overflow(
+		proclist->count, sizeof (acm_processor_id_t), &ovf))
+		return NULL;
+	if (__builtin_uadd_overflow(offset, sizeof (proclist->count), &ovf))
+		return NULL;
+	if (__builtin_uadd_overflow(
+		offset + sizeof (proclist->count),
+		proclist->count * sizeof (acm_processor_id_t), &ovf))
+		return NULL;
+	if (offset +
+		sizeof (proclist->count) +
+		proclist->count * sizeof (acm_processor_id_t) > hdr->size * 4)
+		return NULL;
+
+	return proclist;
+}
+
+static acm_chipset_id_list_t *get_acm_chipset_list(const acm_hdr_t *hdr,
+		const acm_info_table_t *infotable)
+{
+	uint32_t ovf;
+	uint32_t offset;
+	acm_chipset_id_list_t *chiplist;
+
+	offset = infotable->chipset_id_list;
+	chiplist = (acm_chipset_id_list_t *)((void *)hdr + offset);
+
+	/* Check chiplist is contained in ACM size. */
+	if (__builtin_umul_overflow(
+		chiplist->count, sizeof (acm_chipset_id_t), &ovf))
+		return NULL;
+	if (__builtin_uadd_overflow(offset, sizeof (chiplist->count), &ovf))
+		return NULL;
+	if (__builtin_uadd_overflow(
+		offset + sizeof (chiplist->count),
+		chiplist->count * sizeof (acm_chipset_id_t), &ovf))
+		return NULL;
+	if (offset + sizeof (chiplist->count) +
+		chiplist->count * sizeof (acm_chipset_id_t) > hdr->size * 4)
+		return NULL;
+
+	return chiplist;
+}
+
+static int uuids_equal(const uuid_t *u1, const uuid_t *u2)
+{
+	return (u1->data1 == u2->data1 &&
+		u1->data2 == u2->data2 &&
+		u1->data3 == u2->data3 &&
+		u1->data4 == u2->data4 &&
+		u1->data5[0] == u2->data5[0] &&
+		u1->data5[1] == u2->data5[1] &&
+		u1->data5[2] == u2->data5[2] &&
+		u1->data5[3] == u2->data5[3] &&
+		u1->data5[4] == u2->data5[4] &&
+		u1->data5[5] == u2->data5[5]);
+}
+
+struct acm *acm_load(const char *path)
+{
+	int fd;
+	void *p;
+	struct stat sb;
+	struct acm *acm;
+
+	fd = open(path, O_RDONLY);
+	if (fd < 0) {
+		printd("Failed to open file `%s': %s", path, strerror(errno));
+		return NULL;
+	}
+
+	if (fstat(fd, &sb)) {
+		printd("Failed to get file `%s' status: %s", path, strerror(errno));
+		goto fail_stat;
+	}
+
+	acm = malloc(sizeof (*acm));
+	if (!acm) {
+		printd("malloc failed: %s", strerror(errno));
+		goto fail_alloc;
+	}
+
+	acm->size = sb.st_size;
+	if (acm->size < sizeof (acm_hdr_t)) {
+		printd("Invalid ACM %s: Too small.", path);
+		goto fail_sanity;
+	}
+
+	p = mmap(NULL, acm->size, PROT_READ, MAP_PRIVATE, fd, 0);
+	if (p == NULL) {
+		printd("mmap failed: %s", strerror(errno));
+		goto fail_map;
+	}
+	close(fd);
+
+	acm->header = get_acm_header(p);
+	if (acm->header == NULL) {
+		printd("Invalid ACM %s: Header cannot be found.", path);
+		goto fail_map;
+	}
+
+	acm->infotable = get_acm_info_table(acm->header);
+	if (acm->infotable == NULL) {
+		printd("Invalid ACM %s: Info table cannot be found.", path);
+		goto fail_map;
+	}
+
+	if (!uuids_equal(&acm->infotable->uuid, &ACM_UUID_V3)) {
+		printd("Invalid ACM %s: UUID mismatch.", path);
+		goto fail_map;
+	}
+
+	acm->chiplist = get_acm_chipset_list(acm->header, acm->infotable);
+	if (acm->chiplist == NULL) {
+		printd("Invalid ACM %s: Chipset list cannot be found.", path);
+		goto fail_map;
+	}
+
+	if (acm->infotable->version < 4)
+		acm->cpulist = NULL;
+	else {
+		acm->cpulist = get_acm_processor_list(acm->header, acm->infotable);
+		if (acm->cpulist == NULL) {
+			printd("Invalid ACM %s: Processor list cannot be found.", path);
+			goto fail_map;
+		}
+	}
+
+	return acm;
+
+fail_map:
+	munmap(acm->header, acm->size);
+fail_sanity:
+	free(acm);
+fail_alloc:
+fail_stat:
+	close(fd);
+
+	return NULL;
+}
+
+void acm_unload(struct acm *acm)
+{
+	munmap(acm->header, acm->size);
+	free(acm);
+}
diff --git a/pcr-calc/acm.h b/pcr-calc/acm.h
new file mode 100644
index 0000000..386b331
--- /dev/null
+++ b/pcr-calc/acm.h
@@ -0,0 +1,134 @@
+#ifndef _ACM_H_
+# define _ACM_H_
+
+# include <stddef.h>
+# include <inttypes.h>
+
+# include "../include/mle.h"
+
+/*
+ * ACM flags; tboot:acmod.h
+ */
+typedef union {
+	uint16_t raw;
+	struct {
+		uint16_t  reserved       : 14;
+		uint16_t  pre_production : 1;
+		uint16_t  debug_signed   : 1;
+	};
+} acm_flags_t;
+
+/*
+ * ACM header; tboot:acmod.h
+ */
+typedef struct {
+#define ACM_TYPE_CHIPSET    0x02
+	uint16_t     module_type;
+
+#define ACM_SUBTYPE_RESET   0x01
+	uint16_t     module_subtype;
+
+	uint32_t     header_len;
+	uint32_t     header_ver;    /* currently 0.0 */
+	uint16_t     chipset_id;
+	acm_flags_t  flags;
+
+#define ACM_VENDOR_INTEL    0x8086
+	uint32_t     module_vendor;
+
+	uint32_t     date;
+	uint32_t     size;
+	uint16_t     txt_svn;
+	uint16_t     se_svn;
+	uint32_t     code_control;
+	uint32_t     error_entry_point;
+	uint32_t     gdt_limit;
+	uint32_t     gdt_base;
+	uint32_t     seg_sel;
+	uint32_t     entry_point;
+	uint8_t      reserved2[64];
+	uint32_t     key_size;
+	uint32_t     scratch_size;
+	uint8_t      rsa2048_pubkey[256];
+	uint32_t     pub_exp;
+	uint8_t      rsa2048_sig[256];
+	uint32_t     scratch[143];
+	uint8_t      user_area[];
+}__attribute__((packed)) acm_hdr_t;
+
+/*
+ * ACM Info table; tboot:acmod.h
+ */
+typedef struct {
+#define ACM_UUID_V3	((uuid_t){0x7fc03aaa, 0x46a7, 0x18db, 0xac2e, \
+		{0x69, 0x8f, 0x8d, 0x41, 0x7f, 0x5a}})
+	uuid_t     uuid;
+	uint8_t    chipset_acm_type;
+	uint8_t    version;             /* currently 4 */
+	uint16_t   length;
+	uint32_t   chipset_id_list;
+	uint32_t   os_sinit_data_ver;
+	uint32_t   min_mle_hdr_ver;
+	txt_caps_t capabilities;
+	uint8_t    acm_ver;
+	uint8_t    reserved[3];
+	/* versions>= 4 */
+	uint32_t   processor_id_list;
+	/* versions>= 5 */
+	uint32_t   tpm_info_list_off;
+}__attribute__((packed)) acm_info_table_t;
+
+/*
+ * ACM Processor IDs; tboot:acmod.h
+ */
+typedef struct {
+	uint32_t fms;
+	uint32_t fms_mask;
+	uint64_t platform_id;
+	uint64_t platform_mask;
+}__attribute__((packed)) acm_processor_id_t;
+
+/*
+ * ACM Processor ID list; tboot:acmod.h
+ */
+typedef struct {
+	uint32_t             count;
+	acm_processor_id_t   processor_ids[];
+}__attribute__((packed)) acm_processor_id_list_t;
+
+/*
+ * ACM Chipset IDs; tboot:acmod.h
+ */
+typedef struct {
+#define CHIPSET_FLAGS_REVISION_MASK 0x1
+	uint32_t flags;
+	uint16_t vendor_id;
+	uint16_t device_id;
+	uint16_t revision_id;
+	uint16_t reserved;
+	uint32_t extended_id;
+}__attribute__((packed)) acm_chipset_id_t;
+
+/*
+ * ACM Chipset IDs list; tboot:acmod.h
+ */
+typedef struct {
+	uint32_t            count;
+	acm_chipset_id_t    chipset_ids[];
+}__attribute__((packed)) acm_chipset_id_list_t;
+
+/*
+ * ACM main abstraction struct.
+ */
+struct acm {
+	acm_hdr_t *header;
+	acm_info_table_t *infotable;
+	acm_processor_id_list_t *cpulist;
+	acm_chipset_id_list_t *chiplist;
+	size_t size;
+};
+
+struct acm *acm_load(const char *path);
+void acm_unload(struct acm *acm);
+
+#endif /* _ACM_H_ */
diff --git a/pcr-calc/eventlog.c b/pcr-calc/eventlog.c
index b232449..f4335ba 100644
--- a/pcr-calc/eventlog.c
+++ b/pcr-calc/eventlog.c
@@ -35,14 +35,187 @@
 #include <stdio.h>
 #include <stdint.h>
 #include <stdbool.h>
+#include <openssl/evp.h>
 
 #include "uuid.h"
 #include "heap.h"
+#include "acm.h"
 #include "tpm.h"
-
+#include "eventlog.h"
 
 #define error_msg(fmt, ...)         fprintf(stderr, fmt, ##__VA_ARGS__)
 
+static int get_ossinit_caps_tboot_common(const txt_caps_t *acm_caps,
+		const txt_caps_t *mle_hdr, const txt_caps_t *mask,
+		uint8_t tpmver, txt_caps_t *caps)
+{
+	txt_caps_t ossinit_data_caps;
+
+	ossinit_data_caps._raw = mle_hdr->_raw & ~mask->_raw;
+
+	if (acm_caps->rlp_wake_monitor)
+		ossinit_data_caps.rlp_wake_monitor = 1;
+	else if (acm_caps->rlp_wake_getsec)
+		ossinit_data_caps.rlp_wake_getsec = 1;
+	else
+		return -1;
+
+	/* TODO: Can be forced on cmdline too. */
+	switch (tpmver) {
+		case TPM12:
+			ossinit_data_caps.tcg_event_log_format = 0;
+			break;
+		case TPM20:
+			/* TODO: Can be forced to legacy on cmdline. */
+			if (acm_caps->tcg_event_log_format)
+				ossinit_data_caps.tcg_event_log_format = 1;
+			break;
+		default:
+			return -1;
+	}
+
+	/* XXX: Forced to 0 for now (and masked anyway). May change? */
+	ossinit_data_caps.ecx_pgtbl = 0;
+
+	switch (tpmver) {
+		case TPM12:
+			ossinit_data_caps.pcr_map_no_legacy = 1;
+			ossinit_data_caps.pcr_map_da = 0;
+			/* TODO: Has to be enabled on cmdline (pcr_map). */
+			if (acm_caps->pcr_map_da && 0)
+				ossinit_data_caps.pcr_map_da = 1;
+			else if (!acm_caps->pcr_map_no_legacy)
+				ossinit_data_caps.pcr_map_no_legacy = 0;
+			else if (acm_caps->pcr_map_da)
+				ossinit_data_caps.pcr_map_da = 1;
+			else
+				return -1;
+			break;
+		case TPM20:
+			/* PCR mapping selection MUST be zero in TPM2.0 mode
+			 * since D/A mapping is the only supported by TPM2.0 */
+			ossinit_data_caps.pcr_map_no_legacy = 0;
+			ossinit_data_caps.pcr_map_da = 0;
+			break;
+		default:
+			return -1;
+	}
+
+	caps->_raw = ossinit_data_caps._raw;
+
+	return 0;
+}
+
+/* See tboot/txt/txt.c, include/mle.h */
+static int get_ossinit_caps_tboot196(const struct acm *acm, uint8_t tpmver,
+		txt_caps_t *caps)
+{
+	const txt_caps_t mle_hdr = {
+		.rlp_wake_getsec = 1,
+		.rlp_wake_monitor = 1,
+		.ecx_pgtbl = 1,
+		.stm = 0,
+		.pcr_map_no_legacy = 0,
+		.pcr_map_da = 1,
+		.platform_type = 0,
+		.max_phy_addr = 0,
+		.tcg_event_log_format = 1,
+		.reserved1 = 0,
+	};  /* MLE_HDR_CAPS: 0x227 */
+	const txt_caps_t mask = {
+		.rlp_wake_getsec = 1,
+		.rlp_wake_monitor = 1,
+		.ecx_pgtbl = 0,
+		.stm = 0,
+		.pcr_map_no_legacy = 0,
+		.pcr_map_da = 1,
+		.platform_type = 0,
+		.max_phy_addr = 0,
+		.tcg_event_log_format = 0,
+		.reserved1 = 0,
+	};
+
+	return get_ossinit_caps_tboot_common(&acm->infotable->capabilities,
+			&mle_hdr, &mask, tpmver, caps);
+}
+
+/* See tboot/txt/txt.c, include/mle.h */
+/* Since 1.9.6: tcg_event_log_format is now masked before processing, so the
+ * value from the MLE header defined in TBoot is ignored. */
+static int get_ossinit_caps_tboot199(const struct acm *acm, uint8_t tpmver,
+		txt_caps_t *caps)
+{
+	const txt_caps_t mle_hdr = {
+		.rlp_wake_getsec = 1,
+		.rlp_wake_monitor = 1,
+		.ecx_pgtbl = 1,
+		.stm = 0,
+		.pcr_map_no_legacy = 0,
+		.pcr_map_da = 1,
+		.platform_type = 0,
+		.max_phy_addr = 0,
+		.tcg_event_log_format = 1,
+		.reserved1 = 0,
+	};  /* MLE_HDR_CAPS: 0x227 */
+	const txt_caps_t mask = {
+		.rlp_wake_getsec = 1,
+		.rlp_wake_monitor = 1,
+		.ecx_pgtbl = 0,
+		.stm = 0,
+		.pcr_map_no_legacy = 0,
+		.pcr_map_da = 1,
+		.platform_type = 0,
+		.max_phy_addr = 0,
+		.tcg_event_log_format = 1,
+		.reserved1 = 0,
+	};
+
+	return get_ossinit_caps_tboot_common(&acm->infotable->capabilities,
+			&mle_hdr, &mask, tpmver, caps);
+}
+
+static int event_ossinit_data_cap_hash(const struct acm *acm, uint16_t alg,
+		uint8_t tpmver, tb_version_t tbver, tb_hash_t *hash)
+{
+	txt_caps_t caps;
+	int rc;
+
+	switch (tbver) {
+		case TB_196:
+			rc = get_ossinit_caps_tboot196(acm, tpmver, &caps);
+			break;
+		case TB_199:
+			rc = get_ossinit_caps_tboot199(acm, tpmver, &caps);
+			break;
+		default:
+			rc = -1;
+			break;
+	}
+
+	if (!hash_buffer((unsigned char *)&caps, sizeof (caps), hash, alg))
+		return -1;
+
+	return rc;
+}
+
+int emulate_event(const struct acm *acm, uint16_t alg,
+		uint8_t tpmver, tb_version_t tbver, struct pcr_event *evt)
+{
+	int rc;
+
+	switch (evt->type) {
+		case EVTYPE_OSSINITDATA_CAP_HASH:
+			rc = event_ossinit_data_cap_hash(acm, alg, tpmver, tbver,
+					&evt->digest);
+			break;
+		default:
+			rc = -1;
+			break;
+	}
+
+	return rc;
+}
+
 struct tpm *parse_tpm12_log(char *buffer, size_t size)
 {
 	struct tpm *t;
diff --git a/pcr-calc/eventlog.h b/pcr-calc/eventlog.h
index 7329125..c0591f8 100644
--- a/pcr-calc/eventlog.h
+++ b/pcr-calc/eventlog.h
@@ -36,6 +36,24 @@
 #ifndef __EVENTLOG_H__
 #define __EVENTLOG_H__
 
+typedef enum {
+	EVTYPE_BASE                 = 0x400,
+	EVTYPE_PCRMAPPING           = EVTYPE_BASE + 1,
+	EVTYPE_HASH_START           = EVTYPE_BASE + 2,
+	EVTYPE_MLE_HASH             = EVTYPE_BASE + 4,
+	EVTYPE_BIOSAC_REG_DATA      = EVTYPE_BASE + 10,
+	EVTYPE_CPU_SCRTM_STAT       = EVTYPE_BASE + 11,
+	EVTYPE_LCP_CONTROL_HASH     = EVTYPE_BASE + 12,
+	EVTYPE_ELEMENTS_HASH        = EVTYPE_BASE + 13,
+	EVTYPE_STM_HASH             = EVTYPE_BASE + 14,
+	EVTYPE_OSSINITDATA_CAP_HASH = EVTYPE_BASE + 15,
+	EVTYPE_SINIT_PUBKEY_HASH    = EVTYPE_BASE + 16,
+	EVTYPE_LCP_HASH             = EVTYPE_BASE + 17,
+} txt_event_type_t;
+
+int emulate_event(const struct acm *acm, uint16_t alg, uint8_t tpmver,
+	tb_version_t tbver, struct pcr_event *evt);
+
 struct tpm *parse_tpm12_log(char *buffer, size_t size);
 struct tpm *parse_tpm20_log(char *buffer, size_t size);
 
diff --git a/pcr-calc/pcr-calc.c b/pcr-calc/pcr-calc.c
index 67b15fc..81aee72 100644
--- a/pcr-calc/pcr-calc.c
+++ b/pcr-calc/pcr-calc.c
@@ -46,6 +46,7 @@
 #include "../include/hash.h"
 #include "uuid.h"
 #include "tb_policy.h"
+#include "acm.h"
 #include "tpm.h"
 #include "util.h"
 #include "eventlog.h"
@@ -78,8 +79,10 @@ static void print_help(void) {
 		"\t-a alg Alogrithm: select what hash alogrithm to use.\n"
 		"\t-p policy_file Tboot Policy: the policy that was/will be used.\n"
 		"\t-m hash_str Multiboot Module: include module hash (MLE first).\n"
-		"\t-e evt_type:hash_str Override PCR events type found in the logs with the provided value.\n"
-		"\t-F file Use the given file as tpm event log (replace /sys/kernel/security/txt/*_binary_evtlog).\n");
+		"\t-e evt_type:<hash_str>|emulate Override PCR events type found in the logs with the provided value or emulate the value entirely (emulation requires TBoot version and ACM to be provided).\n"
+		"\t-F file Use the given file as tpm event log (replace /sys/kernel/security/txt/*_binary_evtlog).\n"
+		"\t-A acm-path Path to the ACM that will be used to emulate events for PCR calculations (see -e).\n"
+		"\t-V tboot-version TBoot version targeted to emulate events for PCR calculations (see -e)\n.");
 }
 
 static bool apply_lg_policy(struct tpm *t, tb_policy_t *policy, size_t pol_size,
@@ -195,18 +198,20 @@ out:
 
 int main(int argc, char *argv[]) {
 	extern int optind;
-	int opt, flags, mb_count = 0, evt_count = 0, ret = 0;
+	int opt, flags, i, mb_count = 0, evt_count = 0, ret = 0;
 	tb_hash_t mb[20] = { 0 };
 	struct pcr_event evt[20];
 	struct tpm *t = NULL;
 	uint16_t alg_override = 0;
 	size_t pol_size = 0;
 	tb_policy_t *policy_file = NULL;
+	struct acm *acm = NULL;
+	tb_version_t tbver = TB_199;
 	char *eventlog = NULL;
 
 	flags = FLAG_TPM12;
 
-	while ((opt = getopt(argc, (char ** const)argv, "h2dclvqa:p:m:e:F:")) != -1) {
+	while ((opt = getopt(argc, (char ** const)argv, "h2dclvqa:p:m:e:F:A:V:")) != -1) {
 		switch (opt) {
 			case 'm':
 				if (mb_count >= 20) {
@@ -278,6 +283,26 @@ int main(int argc, char *argv[]) {
 			case 'F':
 				eventlog = optarg;
 			break;
+			case 'A':
+				if (acm != NULL) {
+					error_msg("ACM path was already set.\n");
+					ret = 1;
+					goto out;
+				}
+				acm = acm_load(optarg);
+				if (!acm) {
+					error_msg("failed to load ACM:%s.\n", optarg);
+					ret = 1;
+					goto out;
+				}
+			break;
+			case 'V':
+				if (read_tboot_version(optarg, &tbver)) {
+					error_msg("invalid tboot version: %s.\n", optarg);
+					ret = 1;
+					goto out;
+				}
+			break;
 			case 'h':
 				print_help();
 				ret = 1;
@@ -345,12 +370,26 @@ int main(int argc, char *argv[]) {
 		return 0;
 	}
 
+	/* Event-type emulation sanity check. */
+	for (i = 0; i < evt_count; ++i)
+		if (evt[i].emulate && acm == NULL) {
+			error_msg("event-type emulation requires valid ACM passed as argument (-A).\n");
+			ret = 1;
+			goto out;
+		}
+
+
 	/* Change/Emulate events in the log according the cmdline. */
 	if (!tpm_substitute_all_events(t, t->alg, evt, evt_count)) {
 		error_msg("failed to apply event substitutions to the event log.\n");
 		ret = 1;
 		goto out;
 	}
+	if (!tpm_emulate_all_events(t, t->alg, evt, evt_count, acm, tbver)) {
+		error_msg("failed to emulate events in the event log.\n");
+		ret = 1;
+		goto out;
+	}
 
 	if (flags & FLAG_DA) {
 		if (!apply_da_policy(t, policy_file, pol_size, mb, mb_count)) {
diff --git a/pcr-calc/tpm.c b/pcr-calc/tpm.c
index 3cd521a..f01c07f 100644
--- a/pcr-calc/tpm.c
+++ b/pcr-calc/tpm.c
@@ -44,7 +44,9 @@
 
 #include "../include/hash.h"
 #include "uuid.h"
+#include "acm.h"
 #include "tpm.h"
+#include "eventlog.h"
 
 
 #define error_msg(fmt, ...)         fprintf(stderr, fmt, ##__VA_ARGS__)
@@ -320,6 +322,62 @@ bool tpm_substitute_event(struct tpm *t, uint16_t alg,
 	return true;
 }
 
+bool tpm_substitute_all_events(struct tpm *t, uint16_t alg,
+			       const struct pcr_event *evt,
+			       unsigned int evt_count)
+{
+	unsigned int i;
+
+	for (i = 0; i < evt_count; ++i)
+		if (!evt[i].emulate)
+			if (!tpm_substitute_event(t, alg, &evt[i]))
+				return false;
+
+	return true;
+}
+
+bool tpm_emulate_event(struct tpm *t, uint16_t alg,
+		       const struct pcr_event *evt,
+		       const struct acm *acm, tb_version_t tbver)
+{
+	unsigned int i, j;
+	struct pcr_bank *b;
+
+	if (!t || !evt)
+		return false;
+
+	b = tpm_get_bank(t, alg);
+	if (!b)
+		return false;
+
+	for (i = 0; i < MAX_PCR; ++i) {
+		struct pcr *p = &b->pcrs[i];
+
+		for (j = 0; j < p->log_idx; ++j)
+			if (p->log[j].type == evt->type)
+				if (emulate_event(acm, alg, t->version, tbver,
+						  &p->log[j]))
+					return false;
+	}
+
+	return true;
+}
+
+bool tpm_emulate_all_events(struct tpm *t, uint16_t alg,
+			    const struct pcr_event *evt, unsigned int evt_count,
+			    const struct acm *acm, tb_version_t tbver)
+{
+	unsigned int i;
+
+	for (i = 0; i < evt_count; ++i)
+		if (evt[i].emulate)
+			if (!tpm_emulate_event(t, alg, &evt[i], acm, tbver))
+				return false;
+
+	return true;
+}
+
+
 bool tpm_clear_all_event(struct tpm *t, uint16_t alg, uint32_t evt_type)
 {
 	int i, j;
diff --git a/pcr-calc/tpm.h b/pcr-calc/tpm.h
index e30adc4..0c8772d 100644
--- a/pcr-calc/tpm.h
+++ b/pcr-calc/tpm.h
@@ -52,6 +52,7 @@
 struct pcr_event {
 	uint32_t type;
 	tb_hash_t digest;
+	int emulate;
 };
 
 #define MAX_PCR 24
@@ -176,6 +177,19 @@ struct pcr_event *tpm_find_event(struct tpm *t, uint16_t alg,
 				uint32_t evt_type, int n);
 bool tpm_substitute_event(struct tpm *t, uint16_t alg,
 			  const struct pcr_event *evt);
+bool tpm_substitute_all_events(struct tpm *t, uint16_t alg,
+			       const struct pcr_event *evt,
+			       unsigned int evt_count);
+typedef enum {
+	TB_196,
+	TB_199,
+} tb_version_t;
+bool tpm_emulate_event(struct tpm *t, uint16_t alg,
+		       const struct pcr_event *evt,
+		       const struct acm *acm, tb_version_t tbver);
+bool tpm_emulate_all_events(struct tpm *t, uint16_t alg,
+			    const struct pcr_event *evt, unsigned int evt_count,
+			    const struct acm *acm, tb_version_t tbver);
 bool tpm_clear_all_event(struct tpm *t, uint16_t alg, uint32_t evt_type);
 bool tpm_recalculate(struct tpm *t);
 void tpm_print(struct tpm *t, uint16_t alg);
diff --git a/pcr-calc/util.c b/pcr-calc/util.c
index a9b643f..9856a19 100644
--- a/pcr-calc/util.c
+++ b/pcr-calc/util.c
@@ -46,6 +46,7 @@
 
 #include "../include/hash.h"
 #include "uuid.h"
+#include "acm.h"
 #include "tpm.h"
 
 #define error_msg(fmt, ...)         fprintf(stderr, fmt, ##__VA_ARGS__)
@@ -138,9 +139,10 @@ out:
 
 /*
  * Parse a string representing a pcr event.
- * Format: <event-id>:<hash>
+ * Format: <event-id>:<hash>|"emulate"
  * e.g, for sha256: '0x40f:5a3e80a37915b1601c363acd1601df7ef257d5d32c664004a2ec0484a4f60628'
  * e.g, for sha512: '0x40f:be688838ca8686e5c90689bf2ab585cef1137c999b48c70b92f67a5c34dc15697b5d11c982ed6d71be1e1e7f7b4e0733884aa97c3f7a339a8ed03577cf74be09
+ * e.g, for emulation: '0x40f:emulate'
  */
 #define PCREVT_BUF_LEN 135
 int read_pcr_event(const char *s, struct pcr_event *evt)
@@ -149,6 +151,7 @@ int read_pcr_event(const char *s, struct pcr_event *evt)
 	char *end = NULL;
 	unsigned long type;
 	tb_hash_t digest;
+	int rc;
 
 	if (len >= PCREVT_BUF_LEN)
 		return -1;
@@ -161,10 +164,33 @@ int read_pcr_event(const char *s, struct pcr_event *evt)
 	if (!end || *end != ':' || s == end)
 		return -1;
 
-	if (!read_hash(&end[1], &digest))
+	if (strcmp_s(&end[1], sizeof ("emulate"), "emulate", &rc) == EOK && !rc)
+		evt->emulate = 1;
+	else if (read_hash(&end[1], &digest))
+		evt->emulate = 0;
+	else
 		return -1;
 
 	evt->type = type;
 	evt->digest = digest;
 	return len;
 }
+
+#define TBVER_BUF_LEN 9
+int read_tboot_version(const char *s, tb_version_t *ver)
+{
+	size_t len = strnlen(s, TBVER_BUF_LEN);
+	int rc;
+
+	if (len >= TBVER_BUF_LEN)
+		return -1;
+
+	if (strcmp_s(s, TBVER_BUF_LEN, "1.9.6", &rc) == EOK && !rc)
+		*ver = TB_196;
+	else if (strcmp_s(s, TBVER_BUF_LEN, "1.9.9", &rc) == EOK && !rc)
+		*ver = TB_199;
+	else
+		return -1;
+
+	return 0;
+}
diff --git a/pcr-calc/util.h b/pcr-calc/util.h
index 41eaf18..57445ab 100644
--- a/pcr-calc/util.h
+++ b/pcr-calc/util.h
@@ -38,9 +38,12 @@
 #include <stdbool.h>
 #include <sys/types.h>
 
-
 bool read_hash(const char *hexstr, tb_hash_t *hash);
 size_t read_file(const char *path, char **buffer);
 int read_pcr_event(const char *s, struct pcr_event *evt);
 
+int read_tboot_version(const char *s, tb_version_t *ver);
+int read_pcr_event_emulate(const char *s,
+	 struct acm **acm, tb_version_t *ver, struct pcr_event *evt);
+
 #endif
-- 
2.21.0

